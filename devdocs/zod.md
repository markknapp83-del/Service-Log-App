# Zod Documentation for Healthcare Service Log Portal

## Overview
Zod is a TypeScript-first schema validation library with static type inference, perfect for healthcare applications requiring strict data validation and type safety.

## Installation and Basic Setup

### Installation
```bash
npm install zod
# or
yarn add zod
# or
pnpm add zod
```

### Basic Usage
```typescript
import { z } from 'zod';

// Create a simple schema
const UserSchema = z.object({
  name: z.string(),
  age: z.number(),
});

// Extract TypeScript type
type User = z.infer<typeof UserSchema>;

// Parse data (throws if invalid)
const user = UserSchema.parse({ name: 'John', age: 30 });

// Safe parse (returns result object)
const result = UserSchema.safeParse({ name: 'John', age: '30' });
if (result.success) {
  console.log(result.data);
} else {
  console.error(result.error);
}
```

## Healthcare Domain Schemas

### Patient Data Schema
```typescript
import { z } from 'zod';

// Custom validators for healthcare data
const phoneNumberSchema = z.string()
  .regex(/^\d{10}$/, 'Phone number must be 10 digits')
  .transform(phone => `${phone.slice(0,3)}-${phone.slice(3,6)}-${phone.slice(6)}`);

const emailSchema = z.string().email().optional().or(z.literal(''));

const dateOfBirthSchema = z.string()
  .regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format')
  .refine(date => {
    const birthDate = new Date(date);
    const today = new Date();
    const age = today.getFullYear() - birthDate.getFullYear();
    return age >= 0 && age <= 150;
  }, 'Invalid date of birth');

const emergencyContactSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  phone: phoneNumberSchema,
  relationship: z.enum([
    'spouse', 'parent', 'child', 'sibling', 
    'guardian', 'friend', 'other'
  ]),
  address: z.object({
    street: z.string(),
    city: z.string(),
    state: z.string().length(2, 'State must be 2 characters'),
    zipCode: z.string().regex(/^\d{5}(-\d{4})?$/, 'Invalid ZIP code'),
  }).optional(),
});

const patientSchema = z.object({
  id: z.string().uuid().optional(), // Generated by system
  firstName: z.string()
    .min(2, 'First name must be at least 2 characters')
    .max(50, 'First name cannot exceed 50 characters')
    .regex(/^[a-zA-Z\s\-']+$/, 'First name contains invalid characters'),
  lastName: z.string()
    .min(2, 'Last name must be at least 2 characters')
    .max(50, 'Last name cannot exceed 50 characters')
    .regex(/^[a-zA-Z\s\-']+$/, 'Last name contains invalid characters'),
  middleName: z.string()
    .max(50, 'Middle name cannot exceed 50 characters')
    .regex(/^[a-zA-Z\s\-']*$/, 'Middle name contains invalid characters')
    .optional(),
  dateOfBirth: dateOfBirthSchema,
  phone: phoneNumberSchema,
  email: emailSchema,
  medicalRecordNumber: z.string()
    .regex(/^MR\d{10,}$/, 'Invalid medical record number format')
    .optional(),
  emergencyContact: emergencyContactSchema,
  insuranceInfo: z.object({
    provider: z.string().min(1, 'Insurance provider is required'),
    policyNumber: z.string()
      .min(5, 'Policy number must be at least 5 characters')
      .max(20, 'Policy number cannot exceed 20 characters'),
    groupNumber: z.string().optional(),
    effectiveDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
    expirationDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
    copayAmount: z.number().positive().optional(),
  }).optional(),
  allergies: z.array(z.object({
    allergen: z.string().min(1, 'Allergen name is required'),
    severity: z.enum(['mild', 'moderate', 'severe']),
    reaction: z.string().min(1, 'Reaction description is required'),
    notes: z.string().max(500, 'Notes cannot exceed 500 characters').optional(),
  })).optional(),
  medications: z.array(z.object({
    name: z.string().min(1, 'Medication name is required'),
    dosage: z.string().min(1, 'Dosage is required'),
    frequency: z.enum([
      'once-daily', 'twice-daily', 'three-times-daily', 
      'four-times-daily', 'as-needed', 'other'
    ]),
    startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
    endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
    prescribedBy: z.string().optional(),
    notes: z.string().max(300, 'Notes cannot exceed 300 characters').optional(),
  })).optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
}).refine(data => {
  // Validate age constraints for certain fields
  const birthDate = new Date(data.dateOfBirth);
  const age = new Date().getFullYear() - birthDate.getFullYear();
  
  // Minors require guardian information
  if (age < 18 && !data.emergencyContact.relationship.includes('guardian')) {
    return false;
  }
  
  return true;
}, {
  message: 'Minors must have a guardian listed as emergency contact',
  path: ['emergencyContact', 'relationship'],
});

export type Patient = z.infer<typeof patientSchema>;
export { patientSchema };
```

### Service Entry Schema
```typescript
const serviceTypeSchema = z.enum([
  'consultation', 'procedure', 'therapy', 
  'diagnostic', 'emergency', 'follow-up'
]);

const serviceStatusSchema = z.enum([
  'scheduled', 'in-progress', 'completed', 
  'cancelled', 'no-show', 'rescheduled'
]);

const prioritySchema = z.enum(['routine', 'urgent', 'emergency']);

const billingSchema = z.object({
  code: z.string()
    .regex(/^[A-Z0-9\-]+$/, 'Invalid billing code format')
    .min(3, 'Billing code must be at least 3 characters'),
  amount: z.number()
    .positive('Amount must be positive')
    .max(50000, 'Amount cannot exceed $50,000'),
  description: z.string()
    .max(200, 'Description cannot exceed 200 characters')
    .optional(),
  insuranceClaim: z.object({
    claimNumber: z.string().optional(),
    authorizationNumber: z.string().optional(),
    copayAmount: z.number().nonnegative().optional(),
    deductibleApplied: z.number().nonnegative().optional(),
  }).optional(),
});

const locationSchema = z.object({
  facility: z.enum([
    'main-hospital', 'outpatient-clinic', 'emergency-dept',
    'surgery-center', 'lab', 'radiology', 'pharmacy'
  ]),
  building: z.string().optional(),
  floor: z.string().optional(),
  room: z.string().optional(),
  address: z.object({
    street: z.string(),
    city: z.string(),
    state: z.string().length(2),
    zipCode: z.string().regex(/^\d{5}(-\d{4})?$/),
  }).optional(),
});

const serviceEntrySchema = z.object({
  id: z.string().uuid().optional(),
  patientId: z.string().uuid('Invalid patient ID'),
  providerId: z.string().uuid('Invalid provider ID'),
  serviceType: serviceTypeSchema,
  scheduledDateTime: z.string()
    .datetime('Invalid date/time format')
    .refine(datetime => {
      const scheduled = new Date(datetime);
      const now = new Date();
      return scheduled > now;
    }, 'Scheduled time must be in the future'),
  actualStartTime: z.string().datetime().optional(),
  actualEndTime: z.string().datetime().optional(),
  duration: z.number()
    .int('Duration must be a whole number')
    .min(15, 'Minimum duration is 15 minutes')
    .max(480, 'Maximum duration is 8 hours'),
  status: serviceStatusSchema,
  priority: prioritySchema,
  location: locationSchema,
  notes: z.string()
    .max(1000, 'Notes cannot exceed 1000 characters')
    .optional(),
  billing: billingSchema.optional(),
  diagnosisCodes: z.array(z.object({
    code: z.string().regex(/^[A-Z]\d{2}(\.\d{1,2})?$/, 'Invalid ICD-10 format'),
    description: z.string(),
    isPrimary: z.boolean().optional(),
  })).optional(),
  vitalSigns: z.object({
    temperature: z.number().min(95).max(110).optional(), // Fahrenheit
    bloodPressure: z.object({
      systolic: z.number().min(60).max(250),
      diastolic: z.number().min(30).max(150),
    }).optional(),
    heartRate: z.number().min(30).max(200).optional(), // BPM
    respiratoryRate: z.number().min(8).max(40).optional(), // per minute
    oxygenSaturation: z.number().min(70).max(100).optional(), // percentage
    weight: z.number().positive().optional(), // pounds
    height: z.number().positive().optional(), // inches
  }).optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
}).refine(data => {
  // Validate actual times if provided
  if (data.actualStartTime && data.actualEndTime) {
    return new Date(data.actualStartTime) < new Date(data.actualEndTime);
  }
  return true;
}, {
  message: 'End time must be after start time',
  path: ['actualEndTime'],
}).refine(data => {
  // Emergency services require specific validations
  if (data.priority === 'emergency') {
    return data.location.facility === 'emergency-dept' || 
           data.location.facility === 'main-hospital';
  }
  return true;
}, {
  message: 'Emergency services must be at hospital or emergency department',
  path: ['location', 'facility'],
}).refine(data => {
  // Procedures require billing information
  if (data.serviceType === 'procedure' && !data.billing) {
    return false;
  }
  return true;
}, {
  message: 'Procedures require billing information',
  path: ['billing'],
});

export type ServiceEntry = z.infer<typeof serviceEntrySchema>;
export { serviceEntrySchema };
```

### User and Authentication Schema
```typescript
const userRoleSchema = z.enum(['admin', 'provider', 'staff', 'patient']);

const permissionSchema = z.object({
  resource: z.enum(['patients', 'services', 'users', 'reports', 'billing']),
  actions: z.array(z.enum(['create', 'read', 'update', 'delete'])),
});

const userSchema = z.object({
  id: z.string().uuid().optional(),
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(30, 'Username cannot exceed 30 characters')
    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),
  email: z.string().email('Invalid email address'),
  passwordHash: z.string().optional(), // Handled separately
  role: userRoleSchema,
  permissions: z.array(permissionSchema).optional(),
  profile: z.object({
    firstName: z.string().min(2).max(50),
    lastName: z.string().min(2).max(50),
    title: z.string().max(100).optional(),
    department: z.enum([
      'emergency', 'cardiology', 'orthopedics', 'pediatrics',
      'oncology', 'radiology', 'surgery', 'administration'
    ]).optional(),
    licenseNumber: z.string()
      .regex(/^[A-Z0-9\-]+$/, 'Invalid license number format')
      .optional(),
    specialization: z.string().max(100).optional(),
    phone: phoneNumberSchema.optional(),
    extension: z.string().regex(/^\d{3,5}$/).optional(),
  }),
  preferences: z.object({
    timezone: z.string().default('America/New_York'),
    language: z.string().default('en'),
    notifications: z.object({
      email: z.boolean().default(true),
      sms: z.boolean().default(false),
      push: z.boolean().default(true),
    }),
    theme: z.enum(['light', 'dark', 'system']).default('system'),
  }).optional(),
  isActive: z.boolean().default(true),
  lastLoginAt: z.string().datetime().optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});

// Login/Registration schemas
const loginSchema = z.object({
  username: z.string().min(1, 'Username is required'),
  password: z.string().min(1, 'Password is required'),
  rememberMe: z.boolean().optional(),
});

const passwordSchema = z.string()
  .min(8, 'Password must be at least 8 characters')
  .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
  .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
  .regex(/[0-9]/, 'Password must contain at least one number')
  .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character');

const registrationSchema = z.object({
  username: userSchema.shape.username,
  email: userSchema.shape.email,
  password: passwordSchema,
  confirmPassword: z.string(),
  profile: userSchema.shape.profile,
  termsAccepted: z.boolean().refine(val => val === true, {
    message: 'You must accept the terms and conditions',
  }),
}).refine(data => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword'],
});

export type User = z.infer<typeof userSchema>;
export type LoginData = z.infer<typeof loginSchema>;
export type RegistrationData = z.infer<typeof registrationSchema>;
export { userSchema, loginSchema, registrationSchema };
```

## Advanced Validation Patterns

### Custom Validation Functions
```typescript
// Custom validators for medical data
const icd10CodeValidator = z.string().refine(
  (code) => /^[A-Z]\d{2}(\.\d{1,2})?$/.test(code),
  { message: 'Invalid ICD-10 diagnosis code format' }
);

const cptCodeValidator = z.string().refine(
  (code) => /^\d{5}$/.test(code),
  { message: 'CPT codes must be exactly 5 digits' }
);

const socialSecurityValidator = z.string()
  .regex(/^\d{3}-\d{2}-\d{4}$/, 'SSN must be in format XXX-XX-XXXX')
  .refine((ssn) => {
    // Additional validation logic
    const digits = ssn.replace(/-/g, '');
    const area = digits.slice(0, 3);
    const group = digits.slice(3, 5);
    const serial = digits.slice(5);
    
    // Check for known invalid patterns
    if (area === '000' || area === '666' || area.startsWith('9')) {
      return false;
    }
    if (group === '00' || serial === '0000') {
      return false;
    }
    
    return true;
  }, { message: 'Invalid Social Security Number' });

// Age-based validation
const ageBasedSchema = z.object({
  dateOfBirth: z.string().datetime(),
  insuranceInfo: z.object({
    provider: z.string(),
    policyNumber: z.string(),
  }).optional(),
}).refine((data) => {
  const birthDate = new Date(data.dateOfBirth);
  const age = new Date().getFullYear() - birthDate.getFullYear();
  
  // Adults over 18 should have insurance info
  if (age >= 18 && !data.insuranceInfo) {
    return false;
  }
  
  return true;
}, {
  message: 'Adults must provide insurance information',
  path: ['insuranceInfo'],
});

// Cross-field validation
const appointmentSchema = z.object({
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
  providerId: z.string().uuid(),
  patientId: z.string().uuid(),
  serviceType: serviceTypeSchema,
}).refine((data) => {
  const start = new Date(data.startTime);
  const end = new Date(data.endTime);
  const duration = (end.getTime() - start.getTime()) / (1000 * 60); // minutes
  
  // Different service types have minimum duration requirements
  const minDurations = {
    consultation: 15,
    procedure: 30,
    therapy: 45,
    diagnostic: 20,
    emergency: 0, // No minimum for emergencies
    'follow-up': 10,
  };
  
  return duration >= minDurations[data.serviceType];
}, {
  message: 'Appointment duration does not meet minimum requirements for service type',
  path: ['endTime'],
});
```

### Conditional and Dynamic Schemas
```typescript
// Dynamic schema based on user role
const createUserFormSchema = (currentUserRole: string) => {
  const baseSchema = z.object({
    username: z.string().min(3),
    email: z.string().email(),
    firstName: z.string().min(2),
    lastName: z.string().min(2),
    role: userRoleSchema,
  });

  // Only admins can create admin users
  if (currentUserRole !== 'admin') {
    return baseSchema.extend({
      role: userRoleSchema.exclude(['admin']),
    });
  }

  return baseSchema;
};

// Conditional billing schema based on insurance
const conditionalBillingSchema = z.discriminatedUnion('hasInsurance', [
  z.object({
    hasInsurance: z.literal(true),
    insuranceProvider: z.string().min(1),
    policyNumber: z.string().min(1),
    copayAmount: z.number().nonnegative(),
  }),
  z.object({
    hasInsurance: z.literal(false),
    paymentMethod: z.enum(['cash', 'credit', 'debit']),
    totalAmount: z.number().positive(),
  }),
]);

// Schema transformation for API compatibility
const apiPatientSchema = patientSchema.omit({
  createdAt: true,
  updatedAt: true,
}).extend({
  // Transform phone number back to digits for API
  phone: z.string().transform(phone => phone.replace(/\D/g, '')),
  
  // Convert dates to ISO strings
  dateOfBirth: z.string().transform(date => new Date(date).toISOString()),
  
  // Serialize complex objects
  emergencyContact: z.object({}).passthrough().transform(contact => JSON.stringify(contact)),
  insuranceInfo: z.object({}).passthrough().transform(info => JSON.stringify(info)).optional(),
});
```

## Error Handling and Custom Messages

### Detailed Error Formatting
```typescript
import { ZodError, ZodIssue } from 'zod';

interface FormattedError {
  field: string;
  message: string;
  code: string;
  path: string[];
}

export function formatZodError(error: ZodError): FormattedError[] {
  return error.issues.map((issue: ZodIssue) => ({
    field: issue.path.join('.'),
    message: issue.message,
    code: issue.code,
    path: issue.path,
  }));
}

// Custom error messages for healthcare context
const patientSchemaWithMessages = z.object({
  firstName: z.string()
    .min(2, 'Patient first name must be at least 2 characters')
    .max(50, 'First name is too long (maximum 50 characters)')
    .regex(/^[a-zA-Z\s\-']+$/, 'First name contains invalid characters'),
  
  dateOfBirth: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Please enter date in YYYY-MM-DD format')
    .refine(date => {
      const birth = new Date(date);
      const today = new Date();
      return birth < today;
    }, 'Date of birth cannot be in the future')
    .refine(date => {
      const birth = new Date(date);
      const age = new Date().getFullYear() - birth.getFullYear();
      return age <= 150;
    }, 'Please verify the date of birth - age seems unrealistic'),
  
  phone: z.string()
    .regex(/^\d{10}$/, 'Phone number must be exactly 10 digits')
    .refine(phone => !phone.startsWith('0'), 'Phone number cannot start with 0')
    .refine(phone => !phone.startsWith('1'), 'Please enter number without country code'),
});

// Context-aware error messages
function getFieldErrorMessage(field: string, error: ZodIssue): string {
  const contextualMessages: Record<string, Record<string, string>> = {
    phone: {
      too_small: 'Phone number is incomplete',
      invalid_string: 'Please enter a valid phone number',
      custom: 'Phone number format is incorrect',
    },
    email: {
      invalid_string: 'Please enter a valid email address',
      custom: 'Email address is already in use',
    },
    dateOfBirth: {
      invalid_string: 'Please enter a valid date',
      custom: 'Age must be realistic for medical records',
    },
  };

  return contextualMessages[field]?.[error.code] || error.message;
}
```

### Form Integration with React Hook Form
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

function PatientRegistrationForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    setError,
    clearErrors,
  } = useForm<Patient>({
    resolver: zodResolver(patientSchema),
    mode: 'onChange', // Real-time validation
  });

  const onSubmit = async (data: Patient) => {
    try {
      // Clear any previous errors
      clearErrors();
      
      // Additional async validation
      const existingPatient = await checkPatientExists(data.phone);
      if (existingPatient) {
        setError('phone', {
          type: 'custom',
          message: 'A patient with this phone number already exists',
        });
        return;
      }

      // Submit the form
      await createPatient(data);
    } catch (error) {
      if (error instanceof ZodError) {
        // Handle Zod validation errors
        const formattedErrors = formatZodError(error);
        formattedErrors.forEach(({ field, message }) => {
          setError(field as keyof Patient, {
            type: 'custom',
            message,
          });
        });
      }
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input
          {...register('firstName')}
          placeholder="First Name"
          className={`form-input ${errors.firstName ? 'border-red-500' : ''}`}
        />
        {errors.firstName && (
          <p className="text-red-600 text-sm mt-1">
            {errors.firstName.message}
          </p>
        )}
      </div>

      <div>
        <input
          {...register('phone')}
          placeholder="Phone Number"
          className={`form-input ${errors.phone ? 'border-red-500' : ''}`}
        />
        {errors.phone && (
          <p className="text-red-600 text-sm mt-1">
            {errors.phone.message}
          </p>
        )}
      </div>

      <button
        type="submit"
        disabled={isSubmitting}
        className="btn-primary"
      >
        {isSubmitting ? 'Creating Patient...' : 'Create Patient'}
      </button>
    </form>
  );
}
```

## API Validation Middleware

### Express.js Validation Middleware
```typescript
import { Request, Response, NextFunction } from 'express';
import { ZodSchema, ZodError } from 'zod';

export function validateRequest<T>(schema: ZodSchema<T>) {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      // Validate request body
      const validatedData = schema.parse(req.body);
      
      // Replace request body with validated data
      req.body = validatedData;
      
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const formattedErrors = formatZodError(error);
        
        return res.status(400).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Request validation failed',
            details: formattedErrors,
          },
        });
      }
      
      next(error);
    }
  };
}

// Usage in Express routes
app.post('/api/patients', 
  validateRequest(patientSchema),
  async (req: Request, res: Response) => {
    // req.body is now typed and validated
    const patient: Patient = req.body;
    
    try {
      const createdPatient = await patientRepository.create(patient);
      res.json({
        success: true,
        data: createdPatient,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: {
          code: 'CREATE_FAILED',
          message: 'Failed to create patient',
        },
      });
    }
  }
);

// Validate query parameters
const paginationSchema = z.object({
  page: z.string().transform(val => parseInt(val)).refine(val => val > 0).optional(),
  limit: z.string().transform(val => parseInt(val)).refine(val => val > 0 && val <= 100).optional(),
  search: z.string().min(2).optional(),
});

export function validateQuery<T>(schema: ZodSchema<T>) {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const validatedQuery = schema.parse(req.query);
      req.query = validatedQuery as any;
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const formattedErrors = formatZodError(error);
        return res.status(400).json({
          success: false,
          error: {
            code: 'QUERY_VALIDATION_ERROR',
            message: 'Query parameter validation failed',
            details: formattedErrors,
          },
        });
      }
      next(error);
    }
  };
}

app.get('/api/patients',
  validateQuery(paginationSchema),
  async (req: Request, res: Response) => {
    const { page = 1, limit = 20, search } = req.query;
    
    const patients = await patientRepository.findAll({
      page,
      limit,
      search,
    });
    
    res.json({
      success: true,
      data: patients,
    });
  }
);
```

## Performance Optimization

### Schema Compilation and Reuse
```typescript
// Pre-compile schemas for better performance
const compiledPatientSchema = patientSchema;
const compiledServiceSchema = serviceEntrySchema;

// Create parsing functions
export const parsePatient = (data: unknown): Patient => {
  return compiledPatientSchema.parse(data);
};

export const safeParsePatient = (data: unknown) => {
  return compiledPatientSchema.safeParse(data);
};

// Async parsing for large datasets
export const parsePatientAsync = async (data: unknown): Promise<Patient> => {
  return new Promise((resolve, reject) => {
    try {
      const result = compiledPatientSchema.parse(data);
      resolve(result);
    } catch (error) {
      reject(error);
    }
  });
};

// Batch validation
export const validatePatientBatch = (patients: unknown[]): Patient[] => {
  const results: Patient[] = [];
  const errors: { index: number; error: ZodError }[] = [];

  for (let i = 0; i < patients.length; i++) {
    const result = compiledPatientSchema.safeParse(patients[i]);
    if (result.success) {
      results.push(result.data);
    } else {
      errors.push({ index: i, error: result.error });
    }
  }

  if (errors.length > 0) {
    throw new Error(`Batch validation failed for ${errors.length} items`);
  }

  return results;
};
```

## Testing Schemas

### Schema Testing Patterns
```typescript
// __tests__/schemas.test.ts
import { describe, test, expect } from '@jest/globals';
import { patientSchema, serviceEntrySchema } from '../schemas';

describe('Patient Schema', () => {
  test('validates correct patient data', () => {
    const validPatient = {
      firstName: 'John',
      lastName: 'Doe',
      dateOfBirth: '1985-01-15',
      phone: '5551234567',
      email: 'john@example.com',
      emergencyContact: {
        name: 'Jane Doe',
        phone: '5551234568',
        relationship: 'spouse' as const,
      },
    };

    const result = patientSchema.safeParse(validPatient);
    expect(result.success).toBe(true);
    
    if (result.success) {
      expect(result.data.firstName).toBe('John');
      expect(result.data.phone).toBe('555-123-4567'); // Transformed format
    }
  });

  test('rejects invalid phone numbers', () => {
    const invalidPatient = {
      firstName: 'John',
      lastName: 'Doe',
      dateOfBirth: '1985-01-15',
      phone: '123', // Invalid phone
      emergencyContact: {
        name: 'Jane Doe',
        phone: '5551234568',
        relationship: 'spouse' as const,
      },
    };

    const result = patientSchema.safeParse(invalidPatient);
    expect(result.success).toBe(false);
    
    if (!result.success) {
      const phoneError = result.error.issues.find(issue => 
        issue.path.includes('phone')
      );
      expect(phoneError?.message).toBe('Phone number must be 10 digits');
    }
  });

  test('validates emergency contact relationship for minors', () => {
    const minorPatient = {
      firstName: 'Child',
      lastName: 'Patient',
      dateOfBirth: new Date(Date.now() - 10 * 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 10 years old
      phone: '5551234567',
      emergencyContact: {
        name: 'Jane Doe',
        phone: '5551234568',
        relationship: 'friend' as const, // Should require guardian for minors
      },
    };

    const result = patientSchema.safeParse(minorPatient);
    expect(result.success).toBe(false);
  });

  test('transforms and validates data correctly', () => {
    const patientData = {
      firstName: 'John',
      lastName: 'Doe',
      dateOfBirth: '1985-01-15',
      phone: '5551234567',
      emergencyContact: {
        name: 'Jane Doe',
        phone: '5551234568',
        relationship: 'spouse' as const,
      },
    };

    const result = patientSchema.parse(patientData);
    
    // Check that phone number was transformed
    expect(result.phone).toBe('555-123-4567');
    
    // Check that optional fields have defaults
    expect(result.allergies).toBeUndefined();
    expect(result.medications).toBeUndefined();
  });
});

describe('Service Entry Schema', () => {
  test('requires billing info for procedures', () => {
    const procedureWithoutBilling = {
      patientId: '123e4567-e89b-12d3-a456-426614174000',
      providerId: '123e4567-e89b-12d3-a456-426614174001',
      serviceType: 'procedure' as const,
      scheduledDateTime: new Date(Date.now() + 86400000).toISOString(), // Tomorrow
      duration: 60,
      status: 'scheduled' as const,
      priority: 'routine' as const,
      location: {
        facility: 'main-hospital' as const,
      },
    };

    const result = serviceEntrySchema.safeParse(procedureWithoutBilling);
    expect(result.success).toBe(false);
    
    if (!result.success) {
      const billingError = result.error.issues.find(issue =>
        issue.message.includes('billing')
      );
      expect(billingError).toBeDefined();
    }
  });

  test('validates emergency service location requirements', () => {
    const emergencyAtWrongLocation = {
      patientId: '123e4567-e89b-12d3-a456-426614174000',
      providerId: '123e4567-e89b-12d3-a456-426614174001',
      serviceType: 'emergency' as const,
      scheduledDateTime: new Date(Date.now() + 3600000).toISOString(), // 1 hour from now
      duration: 30,
      status: 'scheduled' as const,
      priority: 'emergency' as const,
      location: {
        facility: 'outpatient-clinic' as const, // Invalid for emergency
      },
    };

    const result = serviceEntrySchema.safeParse(emergencyAtWrongLocation);
    expect(result.success).toBe(false);
  });

  test('validates time constraints', () => {
    const invalidTimeOrder = {
      patientId: '123e4567-e89b-12d3-a456-426614174000',
      providerId: '123e4567-e89b-12d3-a456-426614174001',
      serviceType: 'consultation' as const,
      scheduledDateTime: new Date(Date.now() + 3600000).toISOString(),
      actualStartTime: new Date(Date.now() + 7200000).toISOString(), // 2 hours from now
      actualEndTime: new Date(Date.now() + 3600000).toISOString(), // 1 hour from now (before start!)
      duration: 60,
      status: 'completed' as const,
      priority: 'routine' as const,
      location: {
        facility: 'main-hospital' as const,
      },
    };

    const result = serviceEntrySchema.safeParse(invalidTimeOrder);
    expect(result.success).toBe(false);
  });
});

// Property-based testing with fast-check
import fc from 'fast-check';

describe('Patient Schema Property Tests', () => {
  test('never accepts invalid phone numbers', () => {
    fc.assert(fc.property(
      fc.string().filter(s => !/^\d{10}$/.test(s)), // Generate invalid phone numbers
      (invalidPhone) => {
        const patientData = {
          firstName: 'John',
          lastName: 'Doe',
          dateOfBirth: '1985-01-15',
          phone: invalidPhone,
          emergencyContact: {
            name: 'Jane Doe',
            phone: '5551234567',
            relationship: 'spouse' as const,
          },
        };

        const result = patientSchema.safeParse(patientData);
        return !result.success;
      }
    ));
  });
});
```

## Best Practices for Healthcare Applications

### 1. Security Considerations
- Never include sensitive fields in schemas meant for client-side validation
- Use separate schemas for different contexts (API, database, frontend)
- Implement proper sanitization alongside validation
- Consider HIPAA compliance requirements

### 2. Error Handling
- Provide clear, actionable error messages
- Avoid exposing internal validation logic
- Implement proper error logging
- Consider internationalization for error messages

### 3. Performance
- Pre-compile schemas where possible
- Use lazy evaluation for complex validations
- Consider async validation for database checks
- Implement proper caching strategies

### 4. Maintainability
- Keep schemas close to their usage
- Use composition and reusability
- Document complex validation rules
- Version schemas for API compatibility

### 5. Testing
- Test both valid and invalid inputs
- Use property-based testing for edge cases
- Test schema composition and inheritance
- Validate error message quality

## Resources
- [Zod Documentation](https://zod.dev/)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [JSON Schema Specification](https://json-schema.org/)
- [React Hook Form with Zod](https://react-hook-form.com/get-started#SchemaValidation)